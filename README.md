## Описание проекта

Этот репозиторий содержит **Telegram‑ориентированную систему управления задачами (ToDo)**.  
Проект состоит из REST‑backend на **Django + Django REST Framework**, базы данных **PostgreSQL**, брокера сообщений **Redis**, системы фоновых задач **Celery** и **Telegram‑бота на Aiogram 3 + aiogram-dialog**, завернутых в **Docker Compose**.

Основная идея:
- **Django backend** хранит задачи и категории, предоставляет REST API.
- **Telegram‑бот** даёт пользователю удобный диалоговый интерфейс для:
  - создания задач,
  - просмотра списка задач,
  - работы с категориями.
- **Celery** отправляет уведомления к дедлайнам задач, используя брокер Redis.

Все сервисы поднимаются одной командой через `docker-compose` и общаются друг с другом по внутренней Docker‑сети.

---

## Архитектура и компоненты

Проект собран вокруг `docker-compose.yml` и содержит два основных каталога:
- `backend/` — Django‑проект и REST API.
- `bot/` — исходный код Telegram‑бота.

В `docker-compose.yml` определены следующие сервисы:

- **Django backend (`backend`)**
  - Запускает Django с Gunicorn.
  - Подключается к PostgreSQL.
  - Предоставляет REST API по HTTP (порт 8000 на хосте).
  - Содержит модели задач, категорий и профиля пользователя (привязка к Telegram).
  - Настроен на часовой пояс `America/Adak`.

- **PostgreSQL (`db`)**
  - Хранит все данные: задачи, категории, пользователей, профили.
  - Доступен только из Docker‑сети под именем хоста `db`.

- **Redis (`redis`)**
  - Используется как брокер сообщений и хранилище результатов для Celery.
  - Необходим для работы фоновых задач и уведомлений.

- **Celery worker (`celery_worker`)**
  - Обрабатывает фоновые задачи, связанные с напоминаниями по задачам.
  - Использует настройки Django и подключение к Redis.

- **Celery beat (`celery_beat`)**
  - Периодически запускает задачи (планировщик), в том числе проверку задач с наступившим `due_date`.

- **Telegram‑бот (`bot`)**
  - Написан с использованием **Aiogram 3** и **aiogram-dialog**.
  - Подключается к backend по REST API (`BACKEND_API_BASE_URL`).
  - Авторизует запросы к API с помощью Telegram‑идентификатора пользователя.
  - Позволяет пользователю создавать задачи и просматривать их список прямо в Telegram.

Взаимодействие выглядит так:
1. Пользователь общается с **Telegram‑ботом**.
2. Бот отправляет запросы к **Django backend** через REST API (внутри Docker‑сети).
3. Backend читает и записывает данные в **PostgreSQL**.
4. Уведомления по дедлайнам задач выполняются через **Celery worker**, который получает задания от **Celery beat** через **Redis**.

---

## Требования к окружению

Для запуска проекта необходимы:

- **Docker** (актуальная версия для вашей ОС).
- **Docker Compose** (обычно встроен в современный Docker Desktop).
- **Telegram Bot Token** — токен для бота, который выдаёт `@BotFather` в Telegram.

Больше ничего устанавливать (Python, PostgreSQL, Redis и т.п.) на хост‑машину не требуется — всё запускается внутри контейнеров.

---

## Переменные окружения

Переменные окружения задаются в файле `.env`, который вы создаёте на основе `env.example` в корне репозитория.

Полный список переменных:

- **DJANGO_SECRET_KEY** — секретный ключ Django.
  - Обязательно замените значение `change-me` на случайную строку в вашем `.env`.
- **DJANGO_DEBUG**
  - `True` или `False`.
  - Для разработки можно оставить `True`.
- **DJANGO_ALLOWED_HOSTS**
  - Список доменов/хостов через запятую, для разработки можно оставить `*`.

- **POSTGRES_DB**
  - Имя базы данных PostgreSQL.
- **POSTGRES_USER**
  - Имя пользователя базы данных.
- **POSTGRES_PASSWORD**
  - Пароль пользователя базы данных.
- **POSTGRES_HOST**
  - Хост базы данных (по умолчанию `db`, соответствует имени сервиса в `docker-compose.yml`).
- **POSTGRES_PORT**
  - Порт PostgreSQL (по умолчанию `5432`).

- **REDIS_URL**
  - URL подключения к Redis, например `redis://redis:6379/0`.

- **TELEGRAM_BOT_TOKEN**
  - Токен вашего Telegram‑бота от `@BotFather`.
  - Обязательно замените `your-telegram-bot-token` на реальный токен.

- **BACKEND_API_BASE_URL**
  - Базовый URL backend для Telegram‑бота.
  - Внутри Docker‑сети это `http://backend:8000`.
- **BOT_REQUEST_TIMEOUT**
  - Таймаут (в секундах) для запросов бота к backend. По умолчанию `15`.

- **TIME_ZONE**
  - Часовой пояс Django и Celery. По умолчанию `America/Adak`, как требуется по заданию.

### Где задаются переменные

1. В корне проекта уже есть файл `env.example` — это образец.
2. Перед запуском создайте рядом файл `.env`:
   - `cp env.example .env`
3. Отредактируйте `.env`, заменив:
   - `DJANGO_SECRET_KEY`
   - `TELEGRAM_BOT_TOKEN`
   - при необходимости `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD` и другие.

Файл `.env` автоматически подключается сервисами в `docker-compose.yml`.

---

## Пошаговый запуск проекта

Ниже приведена минимальная инструкция, начиная с пустой папки.

### 1. Клонирование репозитория

```bash
git clone <repository_url>
cd <repository_name>
```

- **`git clone`** — скачивает исходный код проекта.
- **`cd`** — переходит в каталог проекта.

### 2. Создание `.env`

```bash
cp env.example .env
```

- Копирует пример настроек в рабочий файл `.env`.
- Откройте `.env` в редакторе и:
  - задайте реальный `DJANGO_SECRET_KEY`,
  - подставьте ваш `TELEGRAM_BOT_TOKEN`,
  - при необходимости измените настройки PostgreSQL.

### 3. Первый запуск через Docker Compose

```bash
docker-compose up --build
```

- `--build` гарантирует пересборку образов (особенно важно при первом запуске).
- Docker скачает базовые образы (Python, PostgreSQL, Redis и т.п.) и соберёт образы `backend` и `bot`.
- Первый запуск может занять **от нескольких минут до 10+ минут** в зависимости от скорости интернета и мощности машины.

Во время запуска:
- сервис `db` поднимает PostgreSQL и проходит healthcheck,
- сервис `backend` выполняет миграции `python manage.py migrate` и запускает Gunicorn,
- сервисы `celery_worker` и `celery_beat` запускают обработчики фоновых задач,
- сервис `bot` запускает Telegram‑бота.

### 4. Как понять, что всё запустилось успешно

- В логах `backend` вы должны увидеть, что миграции выполнены без ошибок и сервер слушает порт `8000`.
- В логах `db` не должно быть сообщений об ошибках авторизации или инициализации.
- В логах `celery_worker` и `celery_beat` должен появиться баннер Celery и сообщения о запуске воркера/планировщика.
- В логах `bot` не должно быть ошибок инициализации токена или подключения к backend.

Дополнительно можно открыть в браузере:
- `http://localhost:8000/admin/` — панель администратора Django.
- `http://localhost:8000/api/` — корень REST API.
- 'http://localhost:8000/api/docs/' - корень Swagger

---

## Настройка Django и доступ к админ‑панели

### Миграции

При старте контейнера `backend` автоматически выполняется команда:

```bash
python manage.py migrate
```

поэтому база данных всегда будет актуальной в соответствии с моделями.

### Создание суперпользователя

Чтобы зайти в Django Admin, создайте суперпользователя:

```bash
docker-compose exec backend python manage.py createsuperuser
```

Далее:
- введите имя пользователя,
- укажите e‑mail (опционально),
- задайте пароль.

После этого:
- откройте `http://localhost:8000/admin/`,
- авторизуйтесь под созданным суперпользователем.

В админке вы сможете:
- просматривать и редактировать **Tasks (задачи)**,
- управлять **Categories (категории)**,
- видеть и редактировать **UserProfile** (привязку Django‑пользователя к Telegram).

### Доступ к REST API

Основные эндпоинты:
- `http://localhost:8000/api/tasks/` — CRUD для задач.
- `http://localhost:8000/api/categories/` — CRUD для категорий.
- `http://localhost:8000/api/telegram/register/` — привязка Telegram‑пользователя к Django‑пользователю (используется ботом).

Авторизация для запросов от бота осуществляется автоматически через специальный заголовок, поэтому вручную при работе через Telegram ничего настраивать не нужно.

---

## Использование Telegram‑бота

### Предварительная настройка

1. Создайте бота через `@BotFather` в Telegram.
2. Получите **Bot Token**.
3. Пропишите токен в `.env`:
   - `TELEGRAM_BOT_TOKEN=<ваш_токен>`
4. Перезапустите контейнеры, если вы изменили `.env`:

```bash
docker-compose down
docker-compose up --build
```

### Связка бота и Django‑пользователя

Общая схема:
1. Пользователь общается с ботом в Telegram.
2. Бот знает его `telegram_user_id` и использует его для аутентификации на backend (через заголовок, настроенный внутри кода).
3. При первом обращении backend создаёт Django‑пользователя с уникальным именем (`tg_<telegram_user_id>`) и профиль `UserProfile`, привязанный к этому Telegram‑пользователю.

Таким образом:
- вам не нужно вручную создавать пользователей в Django для работы бота,
- но при необходимости вы можете увидеть и отредактировать их в админ‑панели.

### Основные возможности бота

Через Telegram‑бота пользователь может:
- **создавать задачи** с указанием:
  - названия,
  - описания (опционально),
  - срока выполнения (`due_date`),
  - категорий (многие-ко-многим).
- **просматривать список своих задач**, включая:
  - заголовок,
  - категории,
  - дату создания,
  - статус выполнения.

Интерфейс реализован на **aiogram-dialog**, поэтому создание задач происходит в виде диалога/мастера с последовательными вопросами.

---

## Celery и уведомления

### Как это работает

- При создании задачи в backend указывается поле `due_date`.
- Celery периодически (через `celery_beat`) проверяет задачи, у которых:
  - `due_date` наступил или скоро наступит,
  - уведомление ещё не отправлено (`notification_sent=False`),
  - задача не завершена (`is_completed=False`).
- Для каждой такой задачи запускается фоновая задача Celery, которая:
  - находит Telegram‑пользователя, связанного с владельцем задачи,
  - отправляет уведомление (обычно через Telegram‑бота),
  - помечает задачу как уведомлённую (`notification_sent=True`).

Все вычисления времени выполняются с учётом часового пояса `America/Adak`, заданного в настройках Django и Celery.

### Роль Redis

- Redis используется как **брокер сообщений** и **хранилище результатов** для Celery:
  - Celery beat помещает задания в Redis.
  - Celery worker забирает задания из Redis и выполняет их.

Без Redis Celery‑воркер и планировщик не смогут обмениваться заданиями, поэтому контейнер `redis` обязателен.

### Как проверить, что Celery работает

1. Убедитесь, что контейнеры `celery_worker` и `celery_beat` запущены:

```bash
docker-compose ps
```

2. Посмотрите логи воркера:

```bash
docker-compose logs -f celery_worker
```

3. В логах вы должны увидеть:
   - баннер Celery при старте,
   - периодические сообщения о получении и выполнении задач.

4. Для проверки на практике:
   - создайте задачу с дедлайном в ближайшем будущем через бота или REST API,
   - дождитесь наступления `due_date`,
   - убедитесь, что в логах Celery появилась задача, а в Telegram пришло уведомление (при корректной настройке бота и уведомлений).

---

## Реализация кастомного Primary Key для задач

В модели `Task` используется **кастомный детерминированный первичный ключ**, который:
- **не является UUID**,
- **не является автоинкрементным числом**,
- **не является случайным значением**,
- **не использует функции PostgreSQL**.

### Стратегия генерации PK

При сохранении задачи:
1. Если поле `created_at` ещё не заполнено, оно устанавливается в текущее время (`timezone.now()`).
2. Формируется строка‑основание, включающая:
   - идентификатор пользователя (`user_id`),
   - заголовок задачи (`title`),
   - срок выполнения (`due_date` в формате ISO),
   - временную метку создания (`created_at.timestamp()` в секундах).
3. К этой строке применяется алгоритм **SHA‑256**.
4. Полученный хеш берётся целиком, но в качестве PK используется его **обрезанная часть фиксированной длины** (например, первые 32 символа шестнадцатеричного представления).

Таким образом:
- PK **детерминирован** — при одинаковых входных данных будет один и тот же идентификатор.
- PK **не автоинкрементный** и **не основан на случайности**.
- Генерация происходит в Django‑модели, **без использования функций PostgreSQL**, что удовлетворяет требованиям задания.

Дополнительно:
- комбинация `user_id + title + due_date + created_at` делает вероятность коллизий крайне низкой,
- `id` задаётся как `CharField(primary_key=True, editable=False)`, поэтому Django использует именно это поле как первичный ключ.

---

## Возможные проблемы и их решения

### Конфликты портов

**Симптом:** при запуске `docker-compose up --build` появляются ошибки вида “port is already allocated”.

**Причины и решения:**
- Порт `5432` (PostgreSQL) или `8000` (backend) уже занят другим процессом.
  - Остановите локальные экземпляры PostgreSQL / других приложений на этих портах.
  - Либо измените порты в `docker-compose.yml` (слева от двоеточия) и перезапустите.

### Бот не отвечает

Проверьте:
1. Что в `.env` корректно указан `TELEGRAM_BOT_TOKEN`.
2. Что контейнер `bot` запущен:
   - `docker-compose ps`
3. Что в логах `bot` нет ошибок авторизации или подключения:
   - `docker-compose logs -f bot`
4. Что backend доступен из контейнера бота по адресу `BACKEND_API_BASE_URL` (обычно `http://backend:8000`).

При изменении `.env` не забывайте полностью перезапускать контейнеры:

```bash
docker-compose down
docker-compose up --build
```

### Ошибки миграций

Если при старте backend вы видите ошибки миграций:

1. Убедитесь, что база данных пуста или в консистентном состоянии.
2. Можно попробовать пересоздать контейнер с базой данных (учтите, что данные будут потеряны):

```bash
docker-compose down -v
docker-compose up --build
```

3. После этого миграции будут применены заново.

### Redis / Celery не запускаются

Проверьте:
1. Логи Redis:

```bash
docker-compose logs -f redis
```

2. Логи Celery:

```bash
docker-compose logs -f celery_worker
docker-compose logs -f celery_beat
```

3. Убедитесь, что в `.env` корректно указан `REDIS_URL`.

Если вы меняете `REDIS_URL`, обязательно перезапустите все контейнеры.

---

## Трудности и решения при разработке

- **Разработка детерминированного кастомного первичного ключа**
  - Задача требовала:
    - не использовать UUID,
    - не использовать автоинкремент,
    - не использовать случайные значения и функции PostgreSQL.
  - Решением стала генерация PK на уровне Django‑модели на основе комбинации полей (`user_id`, `title`, `due_date`, `created_at`) с применением SHA‑256 и усечением результата до фиксированной длины.
  - Это обеспечивает детерминированность, отсутствие зависимости от БД и предотвращает использование автоинкремента.

- **Согласование часовых поясов и времени уведомлений**
  - Требовалось использовать конкретный часовой пояс `America/Adak` и обеспечить корректность уведомлений.
  - Часовой пояс был явно задан в настройках Django и Celery, а работа с датами `due_date` и `created_at` реализована через `timezone` для учёта `USE_TZ=True`.

- **Интеграция Telegram‑бота и Django без классической аутентификации**
  - Необходимо было связать Telegram‑пользователя и Django‑пользователя без логина/пароля.
  - Реализован отдельный механизм:
    - бот передаёт Telegram‑ID пользователя,
    - backend автоматически создаёт Django‑пользователя с префиксом `tg_`,
    - профиль `UserProfile` хранит привязку к Telegram‑пользователю и чат‑ID.

Эти решения позволили сохранить простоту запуска проекта через Docker и при этом выполнить все функциональные и архитектурные требования.
